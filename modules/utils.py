#!/usr/bin/env python3\n\"\"\"\nUtils Module\nHelper functions dan utilities untuk Smartclip AI\n\"\"\"\n\nimport os\nimport sys\nimport platform\nimport subprocess\nimport logging\nfrom pathlib import Path\nfrom typing import List, Dict, Any, Optional, Union\nimport json\nimport pickle\nimport hashlib\nimport shutil\nfrom datetime import datetime, timedelta\nimport psutil\nimport threading\nimport time\nfrom urllib.parse import urlparse\nimport re\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass Utils:\n    \"\"\"Utility class dengan helper functions\"\"\"\n    \n    def __init__(self):\n        self.system_info = self._get_system_info()\n        \n    def _get_system_info(self):\n        \"\"\"Get system information\"\"\"\n        return {\n            'platform': platform.system(),\n            'platform_version': platform.version(),\n            'architecture': platform.architecture()[0],\n            'processor': platform.processor(),\n            'python_version': sys.version,\n            'cpu_count': psutil.cpu_count(),\n            'memory_total': psutil.virtual_memory().total,\n            'gpu_available': self._check_gpu_availability()\n        }\n        \n    def _check_gpu_availability(self):\n        \"\"\"Check jika GPU tersedia untuk processing\"\"\"\n        try:\n            import torch\n            return torch.cuda.is_available()\n        except ImportError:\n            return False\n            \n    def format_duration(self, seconds):\n        \"\"\"Format duration dalam seconds ke human readable string\"\"\"\n        if seconds < 60:\n            return f\"{seconds:.1f} detik\"\n        elif seconds < 3600:\n            minutes = seconds // 60\n            remaining_seconds = seconds % 60\n            return f\"{int(minutes)} menit {int(remaining_seconds)} detik\"\n        else:\n            hours = seconds // 3600\n            minutes = (seconds % 3600) // 60\n            return f\"{int(hours)} jam {int(minutes)} menit\"\n            \n    def format_file_size(self, bytes_size):\n        \"\"\"Format file size dalam bytes ke human readable string\"\"\"\n        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:\n            if bytes_size < 1024.0:\n                return f\"{bytes_size:.1f} {unit}\"\n            bytes_size /= 1024.0\n        return f\"{bytes_size:.1f} PB\"\n        \n    def get_file_hash(self, file_path, hash_algo='md5'):\n        \"\"\"Calculate file hash\"\"\"\n        try:\n            hash_func = hashlib.new(hash_algo)\n            with open(file_path, 'rb') as f:\n                for chunk in iter(lambda: f.read(4096), b\"\"):\n                    hash_func.update(chunk)\n            return hash_func.hexdigest()\n        except Exception as e:\n            logger.error(f\"Error calculating hash: {e}\")\n            return None\n            \n    def sanitize_filename(self, filename):\n        \"\"\"Sanitize filename untuk cross-platform compatibility\"\"\"\n        # Remove atau replace invalid characters\n        invalid_chars = '<>:\"/\\\\|?*'\n        for char in invalid_chars:\n            filename = filename.replace(char, '_')\n            \n        # Remove leading/trailing spaces dan dots\n        filename = filename.strip('. ')\n        \n        # Limit length\n        if len(filename) > 200:\n            name, ext = os.path.splitext(filename)\n            filename = name[:200-len(ext)] + ext\n            \n        return filename\n        \n    def ensure_directory(self, path):\n        \"\"\"Ensure directory exists, create if not\"\"\"\n        try:\n            Path(path).mkdir(parents=True, exist_ok=True)\n            return True\n        except Exception as e:\n            logger.error(f\"Error creating directory {path}: {e}\")\n            return False\n            \n    def cleanup_old_files(self, directory, max_age_days=7, pattern='*'):\n        \"\"\"Cleanup old files dalam directory\"\"\"\n        try:\n            directory = Path(directory)\n            if not directory.exists():\n                return 0\n                \n            cutoff_time = time.time() - (max_age_days * 24 * 60 * 60)\n            removed_count = 0\n            \n            for file_path in directory.glob(pattern):\n                if file_path.is_file() and file_path.stat().st_mtime < cutoff_time:\n                    try:\n                        file_path.unlink()\n                        removed_count += 1\n                    except Exception as e:\n                        logger.warning(f\"Could not remove {file_path}: {e}\")\n                        \n            logger.info(f\"Removed {removed_count} old files from {directory}\")\n            return removed_count\n            \n        except Exception as e:\n            logger.error(f\"Error cleaning up directory: {e}\")\n            return 0\n            \n    def get_disk_usage(self, path):\n        \"\"\"Get disk usage statistics untuk path\"\"\"\n        try:\n            usage = shutil.disk_usage(path)\n            return {\n                'total': usage.total,\n                'used': usage.used,\n                'free': usage.free,\n                'percent_used': (usage.used / usage.total) * 100\n            }\n        except Exception as e:\n            logger.error(f\"Error getting disk usage: {e}\")\n            return None\n            \n    def check_dependencies(self):\n        \"\"\"Check jika semua dependencies terinstall\"\"\"\n        required_packages = [\n            'torch', 'cv2', 'numpy', 'librosa', 'whisper',\n            'face_recognition', 'moviepy', 'yt_dlp', 'customtkinter'\n        ]\n        \n        missing_packages = []\n        \n        for package in required_packages:\n            try:\n                __import__(package)\n            except ImportError:\n                missing_packages.append(package)\n                \n        return {\n            'all_installed': len(missing_packages) == 0,\n            'missing_packages': missing_packages,\n            'total_required': len(required_packages),\n            'total_installed': len(required_packages) - len(missing_packages)\n        }\n        \n    def get_system_performance(self):\n        \"\"\"Get current system performance metrics\"\"\"\n        try:\n            cpu_percent = psutil.cpu_percent(interval=1)\n            memory = psutil.virtual_memory()\n            disk = psutil.disk_usage('/')\n            \n            performance = {\n                'cpu_usage_percent': cpu_percent,\n                'memory_usage_percent': memory.percent,\n                'memory_available_gb': memory.available / (1024**3),\n                'disk_usage_percent': (disk.used / disk.total) * 100,\n                'disk_free_gb': disk.free / (1024**3)\n            }\n            \n            # GPU info jika available\n            if self.system_info['gpu_available']:\n                try:\n                    import torch\n                    if torch.cuda.is_available():\n                        gpu_memory = torch.cuda.get_device_properties(0).total_memory\n                        gpu_memory_used = torch.cuda.memory_allocated(0)\n                        performance.update({\n                            'gpu_memory_total_gb': gpu_memory / (1024**3),\n                            'gpu_memory_used_gb': gpu_memory_used / (1024**3),\n                            'gpu_memory_usage_percent': (gpu_memory_used / gpu_memory) * 100\n                        })\n                except Exception:\n                    pass\n                    \n            return performance\n            \n        except Exception as e:\n            logger.error(f\"Error getting system performance: {e}\")\n            return {}\n            \n    def estimate_processing_time(self, video_duration, operations):\n        \"\"\"Estimate processing time berdasarkan video duration dan operations\"\"\"\n        # Base time estimates per minute of video (in seconds)\n        time_estimates = {\n            'download': 10,\n            'video_analysis': 30,\n            'face_tracking': 45,\n            'speaker_diarization': 60,\n            'subtitle_generation': 40,\n            'video_editing': 20\n        }\n        \n        total_estimate = 0\n        video_minutes = video_duration / 60.0\n        \n        for operation in operations:\n            if operation in time_estimates:\n                total_estimate += time_estimates[operation] * video_minutes\n                \n        # Apply system performance factor\n        performance = self.get_system_performance()\n        if performance:\n            cpu_factor = 1.0\n            if performance.get('cpu_usage_percent', 0) > 70:\n                cpu_factor = 1.5  # Slower jika CPU high usage\n                \n            memory_factor = 1.0\n            if performance.get('memory_usage_percent', 0) > 80:\n                memory_factor = 1.3  # Slower jika memory high usage\n                \n            total_estimate *= (cpu_factor * memory_factor)\n            \n        return max(total_estimate, 10)  # Minimum 10 seconds\n        \n    def validate_url(self, url):\n        \"\"\"Validate URL format\"\"\"\n        try:\n            result = urlparse(url)\n            return all([result.scheme, result.netloc])\n        except Exception:\n            return False\n            \n    def validate_video_file(self, file_path):\n        \"\"\"Validate video file\"\"\"\n        try:\n            file_path = Path(file_path)\n            \n            # Check jika file exists\n            if not file_path.exists():\n                return False, \"File tidak ditemukan\"\n                \n            # Check file extension\n            valid_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v', '.flv']\n            if file_path.suffix.lower() not in valid_extensions:\n                return False, f\"Format file tidak didukung. Gunakan: {', '.join(valid_extensions)}\"\n                \n            # Check file size (max 5GB)\n            file_size = file_path.stat().st_size\n            max_size = 5 * 1024 * 1024 * 1024  # 5GB\n            if file_size > max_size:\n                return False, f\"File terlalu besar ({self.format_file_size(file_size)}). Max 5GB\"\n                \n            return True, \"File valid\"\n            \n        except Exception as e:\n            return False, f\"Error validating file: {str(e)}\"\n            \n    def open_folder(self, folder_path):\n        \"\"\"Open folder dalam file explorer\"\"\"\n        try:\n            folder_path = Path(folder_path)\n            if not folder_path.exists():\n                return False\n                \n            system = platform.system()\n            if system == \"Windows\":\n                os.startfile(folder_path)\n            elif system == \"Darwin\":  # macOS\n                subprocess.run([\"open\", str(folder_path)])\n            else:  # Linux\n                subprocess.run([\"xdg-open\", str(folder_path)])\n                \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error opening folder: {e}\")\n            return False\n            \n    def save_json(self, data, file_path, indent=2):\n        \"\"\"Save data ke JSON file dengan error handling\"\"\"\n        try:\n            with open(file_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=indent, ensure_ascii=False, default=str)\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving JSON: {e}\")\n            return False\n            \n    def load_json(self, file_path):\n        \"\"\"Load data dari JSON file dengan error handling\"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                return json.load(f)\n        except Exception as e:\n            logger.error(f\"Error loading JSON: {e}\")\n            return None\n            \n    def save_pickle(self, data, file_path):\n        \"\"\"Save data ke pickle file\"\"\"\n        try:\n            with open(file_path, 'wb') as f:\n                pickle.dump(data, f)\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving pickle: {e}\")\n            return False\n            \n    def load_pickle(self, file_path):\n        \"\"\"Load data dari pickle file\"\"\"\n        try:\n            with open(file_path, 'rb') as f:\n                return pickle.load(f)\n        except Exception as e:\n            logger.error(f\"Error loading pickle: {e}\")\n            return None\n            \n    def create_backup(self, source_path, backup_dir=None):\n        \"\"\"Create backup dari file atau directory\"\"\"\n        try:\n            source_path = Path(source_path)\n            if not source_path.exists():\n                return None\n                \n            if backup_dir is None:\n                backup_dir = source_path.parent / \"backups\"\n                \n            backup_dir = Path(backup_dir)\n            backup_dir.mkdir(exist_ok=True)\n            \n            # Generate backup filename dengan timestamp\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            if source_path.is_file():\n                backup_name = f\"{source_path.stem}_{timestamp}{source_path.suffix}\"\n                backup_path = backup_dir / backup_name\n                shutil.copy2(source_path, backup_path)\n            else:\n                backup_name = f\"{source_path.name}_{timestamp}\"\n                backup_path = backup_dir / backup_name\n                shutil.copytree(source_path, backup_path)\n                \n            logger.info(f\"Backup created: {backup_path}\")\n            return str(backup_path)\n            \n        except Exception as e:\n            logger.error(f\"Error creating backup: {e}\")\n            return None\n            \n    def compress_file(self, file_path, output_path=None, compression='gzip'):\n        \"\"\"Compress file menggunakan specified compression\"\"\"\n        try:\n            import gzip\n            import bz2\n            import lzma\n            \n            file_path = Path(file_path)\n            if not file_path.exists():\n                return None\n                \n            if output_path is None:\n                if compression == 'gzip':\n                    output_path = file_path.with_suffix(file_path.suffix + '.gz')\n                elif compression == 'bz2':\n                    output_path = file_path.with_suffix(file_path.suffix + '.bz2')\n                elif compression == 'xz':\n                    output_path = file_path.with_suffix(file_path.suffix + '.xz')\n                    \n            # Choose compression method\n            if compression == 'gzip':\n                open_func = gzip.open\n            elif compression == 'bz2':\n                open_func = bz2.open\n            elif compression == 'xz':\n                open_func = lzma.open\n            else:\n                raise ValueError(f\"Unsupported compression: {compression}\")\n                \n            # Compress file\n            with open(file_path, 'rb') as f_in:\n                with open_func(output_path, 'wb') as f_out:\n                    shutil.copyfileobj(f_in, f_out)\n                    \n            # Calculate compression ratio\n            original_size = file_path.stat().st_size\n            compressed_size = Path(output_path).stat().st_size\n            compression_ratio = (1 - compressed_size / original_size) * 100\n            \n            logger.info(f\"Compressed {file_path} -> {output_path} ({compression_ratio:.1f}% reduction)\")\n            return str(output_path)\n            \n        except Exception as e:\n            logger.error(f\"Error compressing file: {e}\")\n            return None\n            \n    def monitor_process(self, process_func, *args, **kwargs):\n        \"\"\"Monitor process performance dan resource usage\"\"\"\n        start_time = time.time()\n        start_cpu = psutil.cpu_percent()\n        start_memory = psutil.virtual_memory().used\n        \n        try:\n            result = process_func(*args, **kwargs)\n            \n            end_time = time.time()\n            end_cpu = psutil.cpu_percent()\n            end_memory = psutil.virtual_memory().used\n            \n            stats = {\n                'execution_time': end_time - start_time,\n                'cpu_usage_avg': (start_cpu + end_cpu) / 2,\n                'memory_delta_mb': (end_memory - start_memory) / (1024 * 1024),\n                'success': True,\n                'result': result\n            }\n            \n            return stats\n            \n        except Exception as e:\n            end_time = time.time()\n            return {\n                'execution_time': end_time - start_time,\n                'cpu_usage_avg': psutil.cpu_percent(),\n                'memory_delta_mb': 0,\n                'success': False,\n                'error': str(e),\n                'result': None\n            }\n            \n    def log_system_info(self):\n        \"\"\"Log detailed system information\"\"\"\n        logger.info(\"=== System Information ===\")\n        for key, value in self.system_info.items():\n            if key == 'memory_total':\n                value = self.format_file_size(value)\n            logger.info(f\"{key}: {value}\")\n            \n        # Performance info\n        performance = self.get_system_performance()\n        if performance:\n            logger.info(\"=== Performance Metrics ===\")\n            for key, value in performance.items():\n                if 'percent' in key:\n                    logger.info(f\"{key}: {value:.1f}%\")\n                elif 'gb' in key:\n                    logger.info(f\"{key}: {value:.2f} GB\")\n                else:\n                    logger.info(f\"{key}: {value}\")\n                    \n# Singleton instance\n_utils_instance = None\n\ndef get_utils():\n    \"\"\"Get singleton Utils instance\"\"\"\n    global _utils_instance\n    if _utils_instance is None:\n        _utils_instance = Utils()\n    return _utils_instance\n\n# Test function\nif __name__ == \"__main__\":\n    # Test utils\n    utils = Utils()\n    \n    print(\"Utils module loaded successfully\")\n    print(f\"System: {utils.system_info['platform']} {utils.system_info['architecture']}\")\n    print(f\"GPU available: {utils.system_info['gpu_available']}\")\n    \n    # Test file operations\n    test_data = {\"test\": \"data\", \"timestamp\": datetime.now()}\n    \n    # Test dependencies\n    deps = utils.check_dependencies()\n    print(f\"\\nDependencies: {deps['total_installed']}/{deps['total_required']} installed\")\n    if deps['missing_packages']:\n        print(f\"Missing: {', '.join(deps['missing_packages'])}\")\n    \n    # Test performance\n    perf = utils.get_system_performance()\n    print(f\"\\nCPU Usage: {perf.get('cpu_usage_percent', 0):.1f}%\")\n    print(f\"Memory Usage: {perf.get('memory_usage_percent', 0):.1f}%\")\n    \n    utils.log_system_info()